---
title: 类型转换导致索引失效
date: 2019-09-10 23:25:32
tags: tingle
---

这件事儿的起因说起来挺有意思的，数据库有一张记录用户基础信息的大表暂时叫做user_info表吧，某一天QA同学来找我查问题，我问了用的哪个账号测试的，QA同学说告诉你手机号行么，我说可以，然后顺手写下了这样的SQL：
```
select * from user_info where mobile = xxx;
```
然后我和QA同学就开始了尴尬的等待时间...看着我的查询转啊转，将近15秒才查出来，这时间里我和QA同学当然是假装思考人生和不经意的看窗外的风景，并且还被吐槽了一句，你这软件有问题还是电脑有问题啊。你还别说，我当时真的以为是软件(navicat)或者电脑的问题，作为一个技术人员把锅甩给硬件和环境应该是基本操作吧~
<!--more-->

不过说实话我平时是个还算爱思考的人，事后我就有了一个疑问，这个按照手机号查用户的sql为什么这么慢呢，而且我特意查看了相应的一些接口，也经常会有类似的查询啊，但是接口的返回速度并不慢，要知道代码还有执行时间，接口返回还有网络传输时间，为什么都可以做到毫秒级？

数据库嘛，一说慢查询第一反应就是看看索引咯，我特意看了一下表结构确实没问题，mobile字段有自己的索引，那么就奇怪了这是为啥呢，通过explain看了一下，type显示是all走了全表扫描。这么简单一个sql语句怎么会有问题呢？正在我百思不得其解的时候突然想起来以前看到过的知识点，如果在索引列上使用了类似于计算或者隐式类型转换之类的操作会导致索引失效，一查表结构果不其然，mobile字段使用了varchar，而我错误的使用了数字类型显然进行了隐式类型转换，把sql改成：
```
select * from user_info where mobile = 'xxx'
```
果然结果秒查~再explain一下type显示为const，使用了预期的索引，看来元凶就是**隐式类型转换导致的索引失效**。于是我去看了看以前我写过类似的代码，幸好没有类似的这种只通过mobile查user的，更多的是还有其他查询条件，符合其他索引规则，比较幸运的避免了慢查询的方法。

这个问题很简单但是体现了两个问题：
* 1.对于数据慢查询的问题，比较基础但也最为常见的就是索引失效或者未正确使用索引，遇到问题直接往这个方向查基本八九不离十；
* 2.关于代码和数据库设计规范来说，类似于号码这种字段虽然是数字，但是其本身含义并不是代表大小，而是代表了类似于id的含义，往往位数多，所以在设计时理应设计成varchar类型，回看自己过往的设计有类似于这种数字字段想当然的使用了int型，所以在查询时我也下意识的感觉mobile是int型