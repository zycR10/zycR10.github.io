---
title: MySQL学习笔记（九）普通索引和唯一索引应该如何选择？
date: 2019-11-11 23:33:41
tags:
categories: 
- MySQL
---
***本文摘要 普通索引，唯一索引，chagne buffer***

<!--more-->

仍然使用之前[MySQL学习笔记(三)](https://zycR10.github.io/2019/06/30/mysql-note-20190630-0/)中用过的一张表

```
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```
![](/image/InnoDB_index_model.jpg)

简单的分析一下查询语句和更新语句的性能。

## 查询语句
假设查询语句为select id from T where k = 5。这个查询语句的执行过程是在索引B+树上从跟结点开始，顺着每一层搜索直到叶节点，然后在叶节点的数据页内通过二分法查找数据。
* 对于普通索引来说，找到了第一个记录（5, 500）后还需要继续往后查找，直到找到第一个不是k = 5的记录停止
* 对于唯一索引来说，由于具有唯一性，找到第一条满足k = 5的数据即可停下
但是其实两者的性能差异微乎其微，InnoDB是以一个数据页为单位来进行读写的，所以每次读写一条记录的时候并不是单单取那条结论，而是以页为单位一并读入内存中，在InnoDB中默认的页大小为16k。
所以对于普通查询来说，多的一次查找判断下一条记录只是变化了指针和多一次计算，当然特殊情况比如k = 5正好是页的最后一条数据的话，情况会更复杂一些，但是一个页中可以存放近千个key，所以这件事儿的发生概率很低，所以当计算性能的时候可以将这一步操作耗时忽略不计。

## 更新语句
引入一个change buffer的概念。当需要执行一句更新语句的时候，如果内存中存在就直接更新，如果不存在，InnooDB在不影响数据一致性的情况下会将这个update操作缓存在change buffer中，在下此查询时将数据读取到内存中，然后执行change buffer中的更新语句进行更新。并且这个change buffer也是可以持久化的数据，在磁盘上有拷贝。
将change buffer中的操作应用到原数据上的过程叫做merge，出了访问数据会merge之外，数据库也会定期自动merge。显然这种先将操作放入内存的方式不仅提高了更新效率，也提高了内存利用率。
**使用change buffer的条件 : ** 
对于唯一索引来说，由于在更新前需要判断操作是否违反了唯一性约束，所以要先查询表中是否有对应的记录，那么就肯定会将这条数据读取到内存中来，那么change buffer就失去了存在的意义。因此唯一索引并不会使用到change buffer。
理解了change buffer之后我们来看一下，假如要向表中插入数据（4，4000）
### 情况一，要更新的目标页存在于内存中：
* 对于唯一索引来说，找到3和5之间的位置，判读没有唯一性约束冲突，插入数据，执行结束
* 对于普通索引来说，找到3和5之间的位置，插入数据，执行结束

### 情况二，要更新的目标页不在内存中：
* 对于唯一索引来说，需要将数据读入到内存中，重复情况一的逻辑，执行结束
* 对于普通索引来说，将更新记录存在chagne buffer中，执行结束。

将数据从磁盘读入到内存涉及随机IO的访问，可以说是数据库里成本最高的操作之一。change buffer减少了随机磁盘访问，所以对于性能的提升是明显的。

## change buffer的使用场景
change buffer只能适用于普通索引的情况，但所有技术都有适用场景，而change buffer并不是适用于所有场景：
merge操作才是数据库真正更新数据的时刻，而并非写下update语句的时候，而change buffer的主要作用是类似懒加载的方式延迟这个更新操作，所以在一个数据页做merge操作之前，如果change buffer累计的操作越多，那么肯定收益就越高。因此不难得出结论，change buffer适用于写多读少的场景，数据页会被频繁更新，但不会频繁查询，所以change buffer能够积累足够多的update操作，反之如果一个业务更新后总会被查询那么就会立刻将数据页读入内存做merge操作，这样不仅没有起到缓存更新操作的目的，反而增加了维护chagne buffer的代价，那么效果也就适得其反。类似于统计，日志类的业务模型使用change buffer是比较合适的。

## 索引选择
* 其实两者在查询性能上几乎相差无几，考虑到对更新的影响下，应该尽量选择普通索引。
* 如果每次更新后都会伴随有查询操作，那么就应该果断关闭change buffer有助于提高性能
* 在实际使用中，普通索引+change buffer配合，对于数据量大表的更新优化还是十分明显的

## change buffer和redo log
change buffer听起来很像redo log，这里简单举例一个insert场景区分一下：
```
mysql> insert into t(id,k) values(id1,k1),(id2,k2);
```
我们假设当前k1所在的数据页存在于内存中，而k2所在的数据页不在内存中，带change buffer的更新过程如下图所示：
![](/image/redo_change-buffer.jpg)

1.page1在内存中，直接更新内存
2.page2不在内存中，向change buffer中写入更新操作
3.将1和2写入redo log中

这个操作过程是非常快的，因为都是在内存中进行，图中的虚线部分是后台处理的操作，并不影响更新的响应时间，并且写入的时候都是顺序写操作。

所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，**redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗**

## 每课一练
change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？



------------
这个问题的答案是不会丢失，留言区的很多同学都回答对了。虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。

**极客时间版权所有: https://time.geekbang.org/column/article/70848**