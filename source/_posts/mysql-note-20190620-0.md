---
title: MySQL学习笔记（二）一条SQL更新语句是如何执行的？
date: 2019-06-20 23:16:10
tags:
categories: 
- MySQL
---
***本文要点：redo log、binlog、两阶段提交***

<!-- more -->

与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log(重做日志)和binlog（归档日志）

## 1.redo log
MySQL作为数据库要经常进行数据的更新，如果每一次的更新都需要写入磁盘，然后通过磁盘找到那条记录，然后再做更新整个过程IO成本、查找成本都很高，所以MySQL用到了一种**WAL技术**,全称是Write-Ahead Logging，关键思想在于先写日志，再写磁盘。当一条记录需要更新时，InnoDB引擎先写到redo log里，并更新内存，此时已经算作更新结束。等到合适的时候，再将这个操作更新到磁盘里，一般是系统空闲的时候。
redo log是固定大小的，比如配置一组4个文件，每个文件都是1GB，总共可以记录4G的操作，从头开始写，写到末尾再回到开头循环写。
正是因为有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力成为crash-safe。

## 2.binlog
我们前文说MySQL整体来看分为server层和引擎层，redo log属于InnoDB独有，所以是在引擎层，而server层提供了binlog。

假如binlog后我们再看看更新一条数据（id=1，加1操作）的内部流程
a.执行器先通过引擎查找id=1这一行。引擎直接用树搜索到这一行，如果id=1的数据在内存中，则直接返回给执行器，否则先从磁盘读入到内存再返回；
b.执行器拿到数据后把这个值加1，再调用引擎接口写入数据；
c.引擎把数据更新到内存，并记录到redo log中，此时redo log为prepare状态，并告知执行器执行完毕，可以提交事务。
d.执行器生成这个操作的binlog，并把binlog写入磁盘；
e.执行器调用引擎提交事务接口，引擎把redo log改为commit状态，更新完成

下面是上述过程的流程图：
![](/image/update_sql.jpg)

这里的最后三步就是著名的“两阶段提交”

## 3.两阶段提交
为什么要有两阶段提交？我们先来看看假如线上出了问题，需要让数据库恢复到某一天某一秒的状态怎么办？假如我们这里要恢复昨天12点的数据：
*首先，找到最近一次数据库全量备份，将备份恢复到临时库；*
*然后，从备份的时间点开始，加binlog依次取出，一直重放到需要恢复的时间节点的前一刻；*

由于redo log和binlog是两种不同的逻辑，我们可以假设没有两端提交，先写redo log再写binlog，或者顺序反过来。让我们看看接下来会发生什么（**逐渐巴尔韦德化**）

1.**先写redo log后写binlog**。假设redo log写完，binlog还没写时MySQL经历了异常重启，那么由于redo log的存在，数据是可以恢复的，但是由于此时binlog还没有写入，如果用我们上面数据恢复的方法使用binlog恢复，那么就会出现丢失数据的情况。
2.**先写binlog后写redo log**。假设binlog写完，redo log还没写时MySQL发生了crash，在重启后由于redo log中没有记录，这个事务并不会恢复，但是后续使用binlog恢复的时候却会多一个记录出来。

可以看出如果不使用两阶段提交，数据库状态就有可能与使用日志恢复不同。

## 每课一练
问题：定期全量备份的周期取决于系统的重要性，有的是一天一备，有的是一周一备，那么在什么场景下，一天一备比一周一备更有优势呢？或者说它影响了数据库系统的哪个指标？

-------

答案：
1.优势在于数据库系统恢复时间变短，这个优势是显而易见的，更频繁地备份意味着恢复时需要调用更少的binlog；
2.系统对应指标是RTO（恢复目标时间）；
3.缺点也是显而易见的，更频繁的全量备份就会消耗更多的资源，成本的取舍取决于业务的重要性。

****

**极客时间版权所有: https://time.geekbang.org/column/article/68633**