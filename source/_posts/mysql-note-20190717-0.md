---
title: MySQL学习笔记（六）全局锁和表锁 ：给表加个字段怎么有这么多阻碍？
date: 2019-07-17 23:26:51
tags:
categories:
- MySQL
---
***本文要点：全局锁，表级锁***
<!--more-->

## 全局锁
对整个数据库实例加锁，数据库只读
* 如果对主库加锁，会造成数据库无法更新，基本所有与更新有关的业务都会停摆
* 如果对从库加锁，会造成主从同步binlog暂停，导致主从延迟

## 表级锁
MySQL中表锁分为两种，一种是表锁，一种是元数据锁（meta data lock，MDL）
**表锁的语法是lock tables ... read/write**,可以使用unlock table释放锁，需要注意的是lock tables除了会限制其他线程的读写之外，也会限制本线程操作对象。

举个例子，如果在线程A中执行了lock tables t1 read, t2 write;这个语句，则其他线程写t1和读写t2都会被阻塞，并且在执行unlock之前线程A也只能读t1，读写t2的操作，连写t1都不允许。

**另一类表锁是MDL。**MDL不需要显式使用，在访问一个表的时候会自动添加。MDL的主要作用的保证读写的正确性。当对一个表进行增删改查的时候加MDL读锁；当对表结构变更操作的时候加MDL写锁。
* 读锁之间不互斥，因此你可以多个线程对一张表增删改查
* 读锁与写锁、写锁之间都是互斥的，如果有两个线程同时给一个表加字段，其中一个要等另一个执行结束

一个很多人都踩过的坑：
给一个表加字段或者加索引需要扫描全表，这个大部分人都很清楚，在对大表操作的时候你肯定会特别小心，以免给线上服务带来问题，但是实际上，即使是小表操作不慎也会出问题，我们来看下图，假设t是一个小表：
![](/image/mdl_lock.jpg)

sessionA启动后为表t加读锁，sessionB启动后也需要加读锁，所以此时还没有问题，但是当sessionC启动后由于sessionC需要修改表结构所以要加写锁，这就导致sessionC被block，只有sessionC被block没关系，但是后续所有申请读写锁的操作都会被block，也就是说这个表现在完全不可读写，如果此时客户端存在超时重试等机制例如新建session的话那么数据库线程将很快被打满。
**那么如何安全的给小表加字段呢？**
首先应该避免长事务的存在，事务不提交MDL锁就一直在，或者也可以选择主动kill掉这个长事务。但是假如这是一张热点表，请求频繁但是字段又不得不加怎么办呢？比较理想的机制是在alter table语句里设定等待时间，如果指定时间内拿到了MDL锁最好，拿不到也不要阻塞后续的业务语句，后续再通过开发或者DBA重试命令。

极客时间版权所有: https://time.geekbang.org/column/article/69862