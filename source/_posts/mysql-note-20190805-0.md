---
title: MySQL学习笔记（八）事务到底是隔离的还是不隔离的？
date: 2019-08-05 22:59:38
tags:
categories: 
- MySQL
---

***本文摘要：可重复读，快照，事务隔离***

<!-- more -->

直接看一个例子：
有如下一张表，并执行如图所示三个事务：
```
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);

```
![](/image/trans_test.jpg)

**注意：begin/start transaction命令并不是一个事务的起点，执行之后的第一个操作InnoDB的语句时，事务才真正开始**，所以如果想让事务立刻启动，可以使用start transaction with consisitent snapshot这个命令，生成快照时间同理，一个是在第一条读语句时，一个是在最开始。

事务C没有显式使用begin/commit，表示这个 update 语句本身就是一个事务。事务B是在更新行之后commit。事务A是一个只读事务，并且是在事务B之后查询。大家可以先思考一下此时的结果。

答案肯定跟你想的不太一样，B查到的k是3，A查到的k是1。先不急着说为什么是这个答案，先清楚一些概念：

在MySQL中有两个“视图”的概念：
* 一个是view, 它是一个用查询语句构成的虚拟表，可以用create view...生成，在调用这个view的时候会调用查询语句生成结果。
* 另一个则是InnoDB在实现MVCC的时候用的一致性读视图，consistent read view，用于支持read commited读提交，repeateable read可重复读隔离级别的实现。

## “快照”在MVCC里是怎么工作的
在可重复读隔离级别下，事务在启动时相当于拍了一张照片，这个快照基于整库数据。但是并不是说需要拷贝整个数据库的数据，那就太慢了。InnoDB中每个事务都由一个唯一的事务ID，叫做transaction id，在事务开始时申请并严格保持递增。

每行数据实际上是由多个版本的，当事务更新数据时会生成一个新的数据版本，并且把事务ID记为row trx_id，也就是说一条记录其实有可能有多个版本存储，每个版本都有自己的row trx_id。如下图所示就是多次更新后的数据状态。
![](/image/record_version.jpg)

但是这里所谓的多版本不是物理意义上的多版本，图中的三个虚线箭头其实代表的就是undo log，V1,V2,V3都不是真实存在的，如果需要V2的值，那么则需要从V4一次执行U3，U2才能得到。

实现数据库的快照逻辑：在事务启动时声明，以事务启动时刻为准，在此时刻之前的数据版本可以认为是有效版本，可以读取；在此时刻之后的版本数据则不会读取。InnoDB为每个事务构造一个数组，记录当前启动时刻所有启动了但未提交的事务ID，数组里事务ID的最小值记为**低水位**，当前系统事务ID的最大值加1记为**高水位**，这个视图数组和高水位就组成了事务的一致性视图。

![](/image/read_rule.jpg)

一个数据的row trx_id对于一致性视图来说有如下几种可能：
* 1.在绿色部分，则说明事务已提交或者是当前事务自己生成的，可读；
* 2.在红色部分，则说明事务尚未开始，不可读
* 3.在黄色部分，则包含两种情况：
  a.若row trx_id在数组中，则说明这个版本由为提交事务生成，不可读
  b.若row trx_id在数组中，则说明这个版本由已提交事务生成，可读
因此InnoDB并不需要真的复制所有数据作为快照，而是通过row trx_id和一致性视图的比较判断数据是否可读，从而实现了秒级创建快照的能力。

## 更新逻辑
事务中的update语句先读后写的方式，但此时的读不是可重复读，而是当前读

* 对于可重复读，查询只承认在事务启动前就已经提交完成的数据
* 对于读提交，查询只承认在语句启动前就已经提交完成的数据

数据库的表结构是不支持可重复读的，为什么呢？很简单，因为表结构并不存在类似于row trx_id这样的属性，所以无法做到多版本并存，所以只能进行当前读

**极客时间版权所有: https://time.geekbang.org/column/article/70562**