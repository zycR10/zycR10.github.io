---
title: MySQL学习笔记（五）事务隔离：为什么你改了我还看不见？
date: 2019-07-09 23:20:45
tags:
categories: 
- MySQL 
---
***本文要点：ACID，隔离级别，事务***
<!-- more -->

简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中事务的实现是在引擎层中，这一点很好记忆，因为MySQL中并不是所有引擎都支持事务。MySQL原生的MyISAM就不支持事务，这也是被InnoDB取代的一个重要原因。

## 隔离性与隔离级别

*数据库事务执行的四个基本要素ACID：*
* 原子性Atomicity
* 一致性Consistency
* 隔离性Isolation
* 持久性Durability

*数据库执行期间可能出现的问题：*
* 脏读（dirty read）
* 不可重复度（nonrepeatable read）
* 幻读（phantom read）

*数据库隔离级别：*
* 读未提交（read uncommitted），读未提交是指一个事务尚未提交，其他事务可以看到他做的变更
* 读已提交（read committed），读已提交是指一个事务提交之后，其他事务才能看到他的变更
* 可重复读（repeateable read），可重复读是指一直事务执行期间看到数据始终保持一直，不会出现前后两次读数据不同的问题
* 串行化（serialized），串行化是最高级别隔离，相当于事务串行化的执行，一个接着一个

隔离级别的实现上，数据库里面会创建一个视图，访问的时候结果以视图逻辑结果为准。再“可重复读”的级别下，视图创建于事务启动时，所以整个事务内数据不会发生变化。而在“读提交”的级别下，视图建立在每个SQL开始时，所以会读取到其他事务已经提交的数据。“读未提交”的级别下直接返回数据最新值，没有视图概念。“串行化”级别下用加锁来避免并行访问数据。

## 事务隔离实现
![](/image/trans_isolation.jpg)
假设当前MySQL隔离级别为可重复读，数据库中每条记录在更新时都会记录一条回滚操作，如上图所示，如果一个值从1按顺序更新为2，3，4，则回滚日志中就会有类似图中这样的记录
当前值为4，但是针对这条记录的查询不同时刻的事务可能会有不同的read view，在图中视图ABC分别对应了值1，2，4，同一条记录在数据库中可以有多个版本，这就是数据库的**多版本并发控制（MVCC）**。

回滚日志不能一直保留，删除的条件是：当没有事务再需要用到这些回滚日志时，即系统里没有比这个回滚日志更早的read-view时就可以删除了。所以这里引申出尽量不使用长事务的问题，长事务意味着系统里会存在很老的事务视图，因为这个长事务有可能会访问数据库里的任何数据，所以在事务提交之前，所有它可能用到的回滚日志都必须保留，这会导致占据大量存储空间。

## 事务启动方式
1.显式启动事务，begin或者start transaction，配套的提交语句时commit，回滚语句时rollback。
2.set autocommit = 0，会将当前线程的自动提交关闭，会等待你主动commit或者rollback或者断开连接。


**极客时间版权所有: https://time.geekbang.org/column/article/68963**